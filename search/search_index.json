{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"cli/","title":"CLI Usage","text":"<pre><code>npx bnf-compile ./bnf/\n</code></pre> <p>Once you have <code>bnf-parser</code> installed simply run <code>npx bnf-compile ./bnf/</code> where <code>./bnf/</code> is actually the folder where your bnfs are stored. After running this you will notice multiple artifacts will be generated which is what you will then <code>import</code>/<code>require</code> into your project.</p> <p>Please note that by default this command will generate javascript modules using the <code>import</code>/<code>export</code> syntax, if you are running an environment which does not support <code>import</code>/<code>export</code>, the CLI will not currently be able export artifacts useable in your project.</p>"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#installation","title":"Installation","text":"<p>We recommend for most people installing <code>bnf-parser</code> as purely a dev dependency, and then you never <code>import</code>/<code>require</code> it into your project. However if for some reason you want to generate syntax parsers for a bnf which is unknown at compile time, then you will need to install <code>bnf-parser</code> as a regular dependency.</p> <pre><code>npm install bnf-parser --save-dev\n</code></pre> <p>Optionally if you want to be able to use the cli commands anywhere without setting up a whole npm dependecy environment you can install globally using: <pre><code>npm install bnf-parser -g\n</code></pre></p>"},{"location":"artifact/","title":"Artifacts","text":"<p>After using the CLI to build your artifacts you will see for every bnf file in that folder two files will be generated. <code>{name}.js</code> which includes all of the runtime required code specific to this parser, and a <code>{name}.d.ts</code>. If you include the <code>.js</code> file, typescript will automatically read from the <code>d.ts</code> for you to find out the type structure of your syntax tree.</p> <p>You will also notice a <code>shared.d.ts</code> and a <code>shared.js</code>, this is a small artifact which is shared between all bnf parsers generated to help unify certain types such as <code>ParseError</code>. All of the generated <code>.d.ts</code> and <code>.js</code> must remain in the same folder as each-other, however you can now move them as a group anywhere.</p> <p>Anything generated by the cli will be referred to as an <code>artifact</code> to differentiate them from any component of the <code>bnf-parser</code> library itself.</p>"},{"location":"artifact/bnf/","title":"Using the BNF generated Artifact","text":""},{"location":"artifact/bnf/#functions","title":"Functions","text":"<p>For every term in your BNF there will be a function with the following syntax. When you supply this function with a string it will attempt to parse the string starting from the specific term in the BNF.</p> <p>This means that you could actually group multiple different parsers into one artifact by including them all in the same BNF, then you just call the specific entry points for each one.</p> <pre><code>function program(input: string, mapSource = true): {\nroot       : Term_Program; // the root node of the syntax tree\nreachBytes : number;       // how many bytes where consumed\nisPartial  : boolean;      // did only part of the input parse?\n}\n</code></pre>"},{"location":"artifact/bnf/#argument-mapsource","title":"Argument <code>mapSource</code>","text":"<p>This is enabled by default, however if it is not enabled the <code>.ref</code> attribute will be left as <code>null</code>, and byte to javascript string indices will not be calculated which can save time, especially if you don't care about where the error occurred, and instead just on the syntax tree result.</p>"},{"location":"artifact/bnf/#types","title":"Types","text":"<p>For every term in the BNF node there will also be a type, that type name will start with <code>Term_</code>; with the first letter of the term name capitalized. This will be a type representing the syntax structure at that node.</p> <p>Examples <pre><code>program -&gt; Term_Program\nname -&gt; Term_Name\nexpr_arg -&gt; Term_Expr_arg\n</code></pre></p>"},{"location":"artifact/bnf/#nodes","title":"Nodes","text":"<p>Every node (including terms, and literals) have the following general type, which is then refined by the compiled <code>d.ts</code> <pre><code>type SyntaxNode = {\ntype  : string;\nroot  : string | SyntaxNode[];\nstart : number;                // the BYTE index this node starts at (not string index)\nend   : number;                // the BYTE index the node ends at    (not string index)\nref   : null | ReferenceRange  // see shared artifact\n}\n</code></pre></p>"},{"location":"artifact/shared/","title":"Using the Shared Artifact","text":"<p>This artifact is actually just a clone of the <code>Shared</code> namespace within <code>bnf-parser</code> with some functions embedded from <code>wasm.Runner</code>.</p> <p>Namespaces</p> <ul> <li><code>ParserError</code></li> <li><code>SyntaxNode</code></li> <li><code>ReferenceRange</code></li> <li><code>Reference</code></li> <li><code>DecodeBase64</code></li> </ul> <p>There are also some extra functions which are purely there for the bnf artifacts to import, and not intended for direct use</p> <ul> <li><code>InitParse</code></li> <li><code>MapBytes2String</code></li> <li><code>MapTreeRefs</code></li> <li><code>Parse</code></li> <li><code>Decode</code></li> </ul>"},{"location":"legacy/","title":"Legacy","text":"<p>These documentation is for anyone attempting to use the older <code>v3.0</code> APIs, while they are still fully functional and unchanged, they are now deprecated and will be based out. However you can still read the documentation for them here.</p>"}]}