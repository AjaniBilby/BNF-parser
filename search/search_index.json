{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-400","title":"Version 4.0.0","text":""},{"location":"changelog/#additions","title":"Additions","text":"<ul> <li> Ability to compile BNFs down to WebAssembly</li> <li> Ability to generate type definitions for the syntax tree of a given BNF</li> <li> Now able to represent characters by char code using hexadecimal in literals (wasm only) <code>\\x41</code></li> </ul>"},{"location":"changelog/#changes","title":"Changes:","text":"<ul> <li> All previous APIs moved under the <code>legacy</code> namespace</li> </ul>"},{"location":"changelog/#fixes","title":"Fixes:","text":"<ul> <li> Count not working when applied directly to a range (i.e. <code>\"a\"-&gt;\"z\"+</code>)</li> </ul>"},{"location":"changelog/#version-316","title":"Version 3.1.6","text":""},{"location":"changelog/#patch","title":"Patch:","text":"<ul> <li> NPM ignore some how removed <code>/bin/lib</code></li> </ul>"},{"location":"changelog/#version-315","title":"Version 3.1.5","text":""},{"location":"changelog/#tweaks","title":"Tweaks:","text":"<ul> <li> Better webpack support     No reliance on <code>fs</code> for deployment.     Now generates a javascript file containing all start up requirements.</li> </ul>"},{"location":"changelog/#version-314","title":"Version 3.1.4","text":""},{"location":"changelog/#tweaks_1","title":"Tweaks:","text":"<ul> <li> Added extra test case <code>Sequalize</code></li> <li> Clarified readme documentation further</li> <li> Synced up some documentation inconsistencies between NPM and Github</li> <li> Fixed typo in previous version number's changelog</li> <li> Got ChatGPT-4 to read my homework (read over the readme and helped clarify a few things)</li> </ul>"},{"location":"changelog/#version-313","title":"Version 3.1.3","text":""},{"location":"changelog/#fixes_1","title":"Fixes:","text":"<ul> <li> Fixed missing bound check on getting reach of a SyntaxNode</li> </ul>"},{"location":"changelog/#tweaks_2","title":"Tweaks:","text":"<ul> <li> Clarified readme documentation</li> </ul>"},{"location":"changelog/#version-312","title":"Version 3.1.2","text":""},{"location":"changelog/#fixes_2","title":"Fixes:","text":"<ul> <li> Updated readme to clarify behaviour of select statements</li> </ul>"},{"location":"changelog/#version-311","title":"Version 3.1.1","text":""},{"location":"changelog/#fixes_3","title":"Fixes:","text":"<ul> <li> Incorrect referencing for syntax errors.</li> </ul>"},{"location":"changelog/#version-310","title":"Version 3.1.0","text":""},{"location":"changelog/#added","title":"Added:","text":"<ul> <li> Documentation dictating the syntax tree structure generated</li> </ul>"},{"location":"changelog/#changes_1","title":"Changes:","text":"<ul> <li> Updates to test case logging</li> <li> New internal string parsing method</li> <li> Rearranged documentation</li> <li> Runtime type check on <code>Compile</code> for non TS users</li> <li> Restructured output Syntax tree to make the layout more stable over BNF changes.</li> </ul>"},{"location":"cli/","title":"CLI Usage","text":"<pre><code>npx bnf-compile ./bnf/\n</code></pre> <p>Once you have <code>bnf-parser</code> installed simply run <code>npx bnf-compile ./bnf/</code> where <code>./bnf/</code> is actually the folder where your bnfs are stored. After running this you will notice multiple artifacts will be generated which is what you will then <code>import</code>/<code>require</code> into your project.</p> <p>Please note that by default this command will generate javascript modules using the <code>import</code>/<code>export</code> syntax, if you are running an environment which does not support <code>import</code>/<code>export</code>, the CLI will not currently be able export artifacts useable in your project.</p>"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#installation","title":"Installation","text":"<p>We recommend for most people installing <code>bnf-parser</code> as purely a dev dependency, and then you never <code>import</code>/<code>require</code> it into your project. However if for some reason you want to generate syntax parsers for a bnf which is unknown at compile time, then you will need to install <code>bnf-parser</code> as a regular dependency.</p> <pre><code>npm install bnf-parser --save-dev\n</code></pre> <p>Optionally if you want to be able to use the cli commands anywhere without setting up a whole npm dependecy environment you can install globally using: <pre><code>npm install bnf-parser -g\n</code></pre></p>"},{"location":"test/","title":"Experiment Online","text":"Browser Performance Warning <p>When you hit <code>run</code> in this playground it compiles the BNF down to WASM, then it uses that wasm to parse the input string, then finally the result is shown</p> <p>This is not indicative of the performance you can expect by actually using this library properly, and the entire compilation step is skipped at runtime as it's already been completed during pre-compilation.</p>"},{"location":"artifact/","title":"Artifacts","text":"<p>After using the CLI to build your artifacts you will see for every bnf file in that folder two files will be generated. <code>{name}.js</code> which includes all of the runtime required code specific to this parser, and a <code>{name}.d.ts</code>. If you include the <code>.js</code> file, typescript will automatically read from the <code>d.ts</code> for you to find out the type structure of your syntax tree.</p> <p>You will also notice a <code>shared.d.ts</code> and a <code>shared.js</code>, this is a small artifact which is shared between all bnf parsers generated to help unify certain types such as <code>ParseError</code>. All of the generated <code>.d.ts</code> and <code>.js</code> must remain in the same folder as each-other, however you can now move them as a group anywhere.</p> <p>Anything generated by the cli will be referred to as an <code>artifact</code> to differentiate them from any component of the <code>bnf-parser</code> library itself.</p>"},{"location":"artifact/individual/","title":"Using the BNF generated Artifact","text":""},{"location":"artifact/individual/#types","title":"Types","text":"<p>For every term in the BNF node there will also be a type, that type name will start with <code>Term_</code>; with the first letter of the term name capitalized. This will be a type representing the syntax structure at that node.</p> <p>Examples <pre><code>program  -&gt; Term_Program\nname     -&gt; Term_Name\nexpr_arg -&gt; Term_Expr_arg\n</code></pre></p>"},{"location":"artifact/individual/#nodes","title":"Nodes","text":"<p>Every node (including terms, and literals) have the following general type, which is then refined by the compiled <code>d.ts</code> <pre><code>type SyntaxNode = {\ntype  : string;\nroot  : string | SyntaxNode[];\nstart : number;                // the BYTE index this node starts at (not string index)\nend   : number;                // the BYTE index the node ends at    (not string index)\nref   : null | ReferenceRange  // see shared artifact\n}\n</code></pre></p>"},{"location":"artifact/individual/#functions","title":"Functions","text":"<p>For every term in your BNF there will be a function with the following syntax. When you supply this function with a string it will attempt to parse the string starting from the specific term in the BNF.</p> <p>This means that you could actually group multiple different parsers into one artifact by including them all in the same BNF, then you just call the specific entry points for each one.</p> <pre><code>function Parse_Program(input: string, mapSource = true): {\nroot       : Term_Program; // the root node of the syntax tree\nreachBytes : number;       // how many bytes where consumed\nisPartial  : boolean;      // did only part of the input parse?\n}\n</code></pre>"},{"location":"artifact/individual/#argument-mapsource","title":"Argument <code>mapSource</code>","text":"<p>This is enabled by default, however if it is not enabled the <code>.ref</code> attribute will be left as <code>null</code>, and byte to javascript string indices will not be calculated which can save time, especially if you don't care about where the error occurred, and instead just on the syntax tree result.</p>"},{"location":"artifact/shared/","title":"Using the Shared Artifact","text":"<p>This artifact is actually just a clone of the <code>Shared</code> namespace within <code>bnf-parser</code> with some functions embedded from <code>wasm.Runner</code>.</p> <p>Namespaces</p> <ul> <li><code>ParserError</code></li> <li><code>SyntaxNode</code></li> <li><code>ReferenceRange</code></li> <li><code>Reference</code></li> <li><code>DecodeBase64</code></li> </ul> <p>There are also some extra functions which are purely there for the bnf artifacts to import, and not intended for direct use</p> <ul> <li><code>InitParse</code></li> <li><code>MapBytes2String</code></li> <li><code>MapTreeRefs</code></li> <li><code>Parse</code></li> <li><code>Decode</code></li> </ul>"},{"location":"legacy/","title":"Legacy","text":"<p>These documentation is for anyone attempting to use the older <code>v3.0</code> APIs, while they are still fully functional and unchanged, they are now deprecated and will be based out. However you can still read the documentation for them here.</p>"}]}