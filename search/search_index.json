{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-405","title":"Version 4.0.5","text":""},{"location":"changelog/#fixes","title":"Fixes:","text":"<ul> <li> References generated on successful pass not having the correct start reference</li> </ul>"},{"location":"changelog/#version-405_1","title":"Version 4.0.5","text":""},{"location":"changelog/#fixes_1","title":"Fixes:","text":"<ul> <li> Hexadecimal characters weren't encoding correctly (<code>\\x6b</code> == <code>k</code>)</li> <li> Reduced changes of wasm infinitely allocating to basically zero (as long as you don't try and parse an infinite string)</li> <li> CLI doesn't crash when given an invalid starting path</li> <li> Removed small chance matching could be attempted in the <code>0</code>-<code>7</code>byte gap after the input string and before the heap starts</li> </ul>"},{"location":"changelog/#changes","title":"Changes:","text":"<ul> <li> CLI now has coloured outputs</li> <li> Binaryen now validates modules after compilation to expose any potential errors in the build chain</li> <li> A lot more automated tests to ensure past errors do not occur again, and to prevent some future ones</li> </ul>"},{"location":"changelog/#version-404","title":"Version 4.0.4","text":""},{"location":"changelog/#fixes_2","title":"Fixes:","text":"<ul> <li> Memory over growth: Available memory kept growing after every single parse</li> <li> Better error handling for <code>bnf-compile</code> when given a bad directory</li> </ul>"},{"location":"changelog/#version-403","title":"Version 4.0.3","text":""},{"location":"changelog/#additions","title":"Additions:","text":"<ul> <li> <code>_Literal</code> helper type in compiled artifacts</li> </ul>"},{"location":"changelog/#version-402","title":"Version 4.0.2","text":""},{"location":"changelog/#fixes_3","title":"Fixes:","text":"<ul> <li> More consistent formatting for generated artifacts</li> <li> More concise types for repetitions (i.e. one to many will always have at least one element according to the type)</li> <li> Consistent file formatting (everything is LF now)</li> </ul>"},{"location":"changelog/#changes_1","title":"Changes:","text":"<ul> <li> Changed to MIT license from ISC</li> </ul>"},{"location":"changelog/#version-401","title":"Version 4.0.1","text":""},{"location":"changelog/#fixes_4","title":"Fixes:","text":"<ul> <li> NPM didn't include some critical files for some reason...</li> </ul>"},{"location":"changelog/#version-400","title":"Version 4.0.0","text":""},{"location":"changelog/#additions_1","title":"Additions","text":"<ul> <li> Compile BNFs down to WebAssembly</li> <li> Generate type definitions for the syntax tree of a given BNF</li> <li> Now able to represent characters by char code using hexadecimal in literals (wasm only) <code>\\x41</code></li> </ul>"},{"location":"changelog/#changes_2","title":"Changes:","text":"<ul> <li> All previous APIs moved under the <code>legacy</code> namespace</li> <li> Changed package type to module</li> </ul>"},{"location":"changelog/#fixes_5","title":"Fixes:","text":"<ul> <li> Count not working when applied directly to a range (i.e. <code>\"a\"-&gt;\"z\"+</code>)</li> </ul>"},{"location":"changelog/#version-316","title":"Version 3.1.6","text":""},{"location":"changelog/#patch","title":"Patch:","text":"<ul> <li> NPM ignore some how removed <code>/bin/lib</code></li> </ul>"},{"location":"changelog/#version-315","title":"Version 3.1.5","text":""},{"location":"changelog/#tweaks","title":"Tweaks:","text":"<ul> <li> Better webpack support     No reliance on <code>fs</code> for deployment.     Now generates a javascript file containing all start up requirements.</li> </ul>"},{"location":"changelog/#version-314","title":"Version 3.1.4","text":""},{"location":"changelog/#tweaks_1","title":"Tweaks:","text":"<ul> <li> Added extra test case <code>Sequalize</code></li> <li> Clarified readme documentation further</li> <li> Synced up some documentation inconsistencies between NPM and Github</li> <li> Fixed typo in previous version number's changelog</li> <li> Got ChatGPT-4 to read my homework (read over the readme and helped clarify a few things)</li> </ul>"},{"location":"changelog/#version-313","title":"Version 3.1.3","text":""},{"location":"changelog/#fixes_6","title":"Fixes:","text":"<ul> <li> Fixed missing bound check on getting reach of a SyntaxNode</li> </ul>"},{"location":"changelog/#tweaks_2","title":"Tweaks:","text":"<ul> <li> Clarified readme documentation</li> </ul>"},{"location":"changelog/#version-312","title":"Version 3.1.2","text":""},{"location":"changelog/#fixes_7","title":"Fixes:","text":"<ul> <li> Updated readme to clarify behaviour of select statements</li> </ul>"},{"location":"changelog/#version-311","title":"Version 3.1.1","text":""},{"location":"changelog/#fixes_8","title":"Fixes:","text":"<ul> <li> Incorrect referencing for syntax errors.</li> </ul>"},{"location":"changelog/#version-310","title":"Version 3.1.0","text":""},{"location":"changelog/#added","title":"Added:","text":"<ul> <li> Documentation dictating the syntax tree structure generated</li> </ul>"},{"location":"changelog/#changes_3","title":"Changes:","text":"<ul> <li> Updates to test case logging</li> <li> New internal string parsing method</li> <li> Rearranged documentation</li> <li> Runtime type check on <code>Compile</code> for non TS users</li> <li> Restructured output Syntax tree to make the layout more stable over BNF changes.</li> </ul>"},{"location":"cli/","title":"CLI Usage","text":"<pre><code>npx bnf-compile ./bnf/\n</code></pre> <p>Once you have <code>bnf-parser</code> installed simply run <code>npx bnf-compile ./bnf/</code> where <code>./bnf/</code> is actually the folder where your bnfs are stored. After running this you will notice multiple artifacts will be generated which is what you will then <code>import</code>/<code>require</code> into your project.</p> <p>Please note that by default this command will generate javascript modules using the <code>import</code>/<code>export</code> syntax, if you are running an environment which does not support <code>import</code>/<code>export</code>, the CLI will not currently be able export artifacts useable in your project.</p>"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#installation","title":"Installation","text":"<p>We recommend for most people installing <code>bnf-parser</code> as purely a dev dependency, and then you never <code>import</code>/<code>require</code> it into your project. However if for some reason you want to generate syntax parsers for a bnf which is unknown at compile time, then you will need to install <code>bnf-parser</code> as a regular dependency.</p> <pre><code>npm install bnf-parser --save-dev\n</code></pre> <p>Optionally if you want to be able to use the cli commands anywhere without setting up a whole npm dependecy environment you can install globally using: <pre><code>npm install bnf-parser -g\n</code></pre></p>"},{"location":"test/","title":"Experiment Online","text":"Browser Performance Warning <p>When you hit <code>run</code> in this playground it compiles the BNF down to WASM, then it uses that wasm to parse the input string, then finally the result is shown</p> <p>This is not indicative of the performance you can expect by actually using this library properly, and the entire compilation step is skipped at runtime as it's already been completed during pre-compilation.</p> <p>If you want to try with code in your browser use RunKit+</p>"},{"location":"api/","title":"API","text":"<p>Warning</p> <p>It is highly recommended to not directly use the APIs unless necessary, and instead rely on artifacts generated by the CLI</p> <p>Using the API can cause a lot of confusion for non-maintainers such as some functions throwing <code>ParseError</code> which is a shared class between <code>legacy</code> and new code, but some other's actually using <code>_shared.ParseError</code> however it will appear under the same name.</p> <p>This is due to some components of this library being fundamental core components, and others are actually compiled by the library itself and using these artifacts as part of itself in a bootstrapping process.</p> <p>Hence there are multiple versions of some types</p> <ul> <li><code>_shared</code></li> <li><code>bnf</code></li> <li><code>legacy</code></li> <li><code>wasm</code></li> </ul>"},{"location":"api/bnf/","title":"<code>bnf</code> Namespace","text":"<p>This namespace is actually an already instantiated bnf parser compiled with the language itself. It shares all similar properties as a regular individual artifact, generated on the syntax for <code>bnf</code>s themselves.</p> <p>It is used internally in the library to parse <code>bnf</code> inputs into <code>SyntaxNode</code>s which are then used for further compilation to either <code>WasmParser</code>, <code>legacy.Parser</code>, or <code>type definitions</code></p>"},{"location":"api/shared/","title":"<code>_shared</code> Namespace","text":""},{"location":"api/shared/#parseerror","title":"ParseError","text":"<p>This class is simply used to bundle a message with a ReferenceRange, while it is primarily used to represent an error while parsing, it is also used for errors in compilation and other events where a message and a ReferenceRange are necessary.</p> <pre><code>export class ParseError {\nmsg: string\nref: ReferenceRange\n\nconstructor(msg: string, ref: ReferenceRange);\ntoString(): string;\n}\n</code></pre>"},{"location":"api/shared/#syntaxnode","title":"SyntaxNode","text":"<p>This class can represent both a branch and a leaf node of a syntax tree. If these are generated by a parse call with source mapping turned off, it and all it's children will share a single instance of ReferenceRange with an invalid column and line number.</p> <p>Please be mindful of this if you attempt to mutate the references on a non-source mapped SyntaxNode.</p> <pre><code>export class SyntaxNode {\ntype : string; // the name of this branch/leaf\nstart: number; // the byte index this node starts at\nend  : number; // the byte index this node ends at\ncount: number; // the number of children, or number of bytes this holds (branch/leaf)\nvalue: SyntaxNode[] | string;\nref: ReferenceRange;\n\nconstructor (type: string, start: number, end: number, count: number, ref: ReferenceRange);\n}\n</code></pre>"},{"location":"api/shared/#reference","title":"Reference","text":"<pre><code>export class Reference {\nline : number; // numbering starts at 1\ncol  : number; // numbering starts at 1\nindex: number; // numbering starts at 0 (JS string index)\n\nconstructor(line: number, col: number, index: number)\nclone(): Reference;\ntoString(): string;\n\nstatic blank() {\nreturn new Reference(1,1,0);\n}\n}\n</code></pre>"},{"location":"api/shared/#referencerange","title":"ReferenceRange","text":"<pre><code>export class ReferenceRange {\nstart: Reference;\nend:   Reference;\n\nconstructor(from: Reference, to: Reference)\nspan(other: ReferenceRange) // Merges itself with another range\nclone(): ReferenceRange\ntoString(): string\n\n// Non-destructively takes two ranges, and returns a new range spanning both\nstatic union(a: ReferenceRange, b: ReferenceRange){\nreturn new ReferenceRange(\na.start.index &lt; b.start.index ? a.start.clone() : b.start.clone(), // Smallest\na.end.index   &gt; b.end.index   ? a.end.clone()   : b.end.clone(),   // Largest\n);\n}\n\n// Non-destructively takes two ranges, and returns a new range of the intersection of both\n// If the two ranges do not intersect you will end up with the range between them\nstatic intersection(a: ReferenceRange, b: ReferenceRange)\n\nstatic blank() {\nreturn new ReferenceRange(Reference.blank(), Reference.blank());\n}\n}\n</code></pre>"},{"location":"api/shared/#assertunreachable","title":"AssertUnreachable","text":"<p>This function is simply a helper function for ensuring you have checked all possible states for a given node.</p> <pre><code>export function AssertUnreachable(x: never): never\n</code></pre> <p>Example bnf<pre><code>component ::= literal | constant | expr ;\n</code></pre> typescript<pre><code>switch (component.type) {\ncase \"literal\": break;\ncase \"constant\": break;\ndefault: AssertUnreachable(component); // will cause compile time error\n// as expr is missing\n}\n</code></pre></p>"},{"location":"api/shared/#decodebase64","title":"DecodeBase64","text":"<p>This function is simply used by artifacts, and not intended for end-user use, but could still be helpful.</p> <pre><code>export function DecodeBase64(base64: string): Uint8Array;\n</code></pre>"},{"location":"api/wasm/","title":"<code>wasm</code> Namespace","text":""},{"location":"api/wasm/#compile2wasm","title":"Compile2Wasm","text":"<p>This is a wrapper around <code>GenerateWasm</code> which allows you to go straight from a string representation of a bnf, down to the binaryen.Module without needing to generate a <code>legacy.Parser</code> first.</p> <pre><code>function Compile2Wasm(inputBnf: string): Shared.ParseError | binaryen.Module\n</code></pre>"},{"location":"api/wasm/#compiletypes","title":"CompileTypes","text":"<p>Takes in a <code>legacy.Parser</code> as input for a bnf syntax, and outputs the corresponding typescript definitions as a string for a compiled artifact which would be generated from the same input</p> <pre><code>function CompileTypes(lang: legacy.Parser): string\n</code></pre>"},{"location":"api/wasm/#generatewasm","title":"GenerateWasm","text":"<p>Takes in a <code>legacy.Parser</code> as input for a bnf syntax, and compiles it down to a binaryen.Module which can then be used to generate <code>.wat</code> and <code>.wasm</code> outputs.</p> <pre><code>function GenerateWasm(lang: legacy.Parser): binaryen.Module\n</code></pre>"},{"location":"api/wasm/#runner","title":"Runner","text":""},{"location":"api/wasm/#runnerwasmparser","title":"Runner.WasmParser","text":"<p>This is just a type interface used by all runners, including ones encoded in an artifact. It is simply used to differentiate a wasm instance generated for BNF parsing, from a generic wasm instance.</p> <pre><code>type WasmParser = WebAssembly.Instance &amp; {\nexports: {\nmemory      : WebAssembly.Memory;\ninput       : WebAssembly.Global;\ninputLength : WebAssembly.Global;\nheap        : WebAssembly.Global;\n\n_init:   () =&gt; number;\nprogram: () =&gt; number;\n// generated artifacts will have extra functions\n//   bound based on the BNF they are generated from\n}\n}\n</code></pre>"},{"location":"api/wasm/#runnercreate","title":"Runner.Create","text":"<p>This takes any <code>BufferSource</code> as input (i.e. <code>Uint8Array</code>), and synchronously generates a wasm instance from it. This function will error in most browsers, as instantiating any WebAssembly module over <code>4KB</code> in size must be non-blocking.</p> <pre><code>function Create(wasm: BufferSource): WasmParser;\n</code></pre>"},{"location":"api/wasm/#runnerparse","title":"Runner.Parse","text":"<p>Supply an already created <code>WasmParser</code> from <code>Runner.Create</code>, a string input for the data to be parsed, as well as two optional modifiers to attempt to generate a syntax tree using the given wasm instance.</p> <pre><code>function Parse(ctx: WasmParser, data: string, refMapping = true, entry = \"program\"): {\nreachBytes: number,\nisPartial: boolean,\nreach: Shared.Reference,\nroot:  SyntaxNode,\n}\n</code></pre>"},{"location":"api/wasm/#argument-refmapping","title":"Argument <code>refMapping</code>","text":"<p>If this is disabled, all SyntaxNodes will share a single <code>ReferenceRange</code> which reduces decode time as the proper references don't need to be calculated during decoding, and nor do new object instances need to be generated reducing allocations.</p> <p>If this is enabled a proper reference range will be generated for every <code>SyntaxNode</code>.</p> <p>You can detect if a <code>SyntaxNode</code> has been source mapped or not, because a non-source mapped node's <code>.ref</code> will have the start and end points being the exact same object (i.e. <code>start === end</code>), but also all values in the <code>Reference</code> will be zero, which is invalid as col and line numbers both start counting from <code>1</code>.</p>"},{"location":"api/wasm/#argument-entry","title":"Argument <code>entry</code>","text":"<p>This tells the parser which term in the bnf to start parsing from.</p>"},{"location":"api/wasm/#runnertostring","title":"Runner.toString","text":"<p>This function is intended for internal use only. It's used to generate the shared artifact</p> <pre><code>function toString(): string;\n</code></pre>"},{"location":"artifact/","title":"Artifacts","text":"<p>After using the CLI to build your artifacts you will see for every bnf file in that folder two files will be generated. <code>{name}.js</code> which includes all of the runtime required code specific to this parser, and a <code>{name}.d.ts</code>. If you include the <code>.js</code> file, typescript will automatically read from the <code>d.ts</code> for you to find out the type structure of your syntax tree.</p> <p>You will also notice a <code>shared.d.ts</code> and a <code>shared.js</code>, this is a small artifact which is shared between all bnf parsers generated to help unify certain types such as <code>ParseError</code>. All of the generated <code>.d.ts</code> and <code>.js</code> must remain in the same folder as each-other, however you can now move them as a group anywhere.</p> <p>Anything generated by the cli will be referred to as an <code>artifact</code> to differentiate them from any component of the <code>bnf-parser</code> library itself.</p>"},{"location":"artifact/individual/","title":"Using the BNF generated Artifact","text":""},{"location":"artifact/individual/#types","title":"Types","text":"<p>For every term in the BNF node there will also be a type, that type name will start with <code>Term_</code>; with the first letter of the term name capitalized. This will be a type representing the syntax structure at that node.</p> <p>Examples <pre><code>program  -&gt; Term_Program\nname     -&gt; Term_Name\nexpr_arg -&gt; Term_Expr_arg\n</code></pre></p>"},{"location":"artifact/individual/#literal","title":"Literal","text":"<p>There is also an added <code>_Literal</code> type, this is mainly to help developers using this library by giving them a type they can use in function arguments, and other type hints that is shorter to type than the entire type definition for a standard literal node.</p>"},{"location":"artifact/individual/#nodes","title":"Nodes","text":"<p>Every node (including terms, and literals) have the following general type, which is then refined by the compiled <code>d.ts</code> <pre><code>type SyntaxNode = {\ntype  : string;\nroot  : string | SyntaxNode[];\nstart : number;                // the BYTE index this node starts at (not string index)\nend   : number;                // the BYTE index the node ends at    (not string index)\nref   : null | ReferenceRange  // see shared artifact\n}\n</code></pre></p>"},{"location":"artifact/individual/#functions","title":"Functions","text":"<p>For every term in your BNF there will be a function with the following syntax. When you supply this function with a string it will attempt to parse the string starting from the specific term in the BNF.</p> <p>This means that you could actually group multiple different parsers into one artifact by including them all in the same BNF, then you just call the specific entry points for each one.</p> <pre><code>function Parse_Program(input: string, mapSource = true): {\nroot       : Term_Program; // the root node of the syntax tree\nreachBytes : number;       // how many bytes where consumed\nisPartial  : boolean;      // did only part of the input parse?\n}\n</code></pre>"},{"location":"artifact/individual/#argument-mapsource","title":"Argument <code>mapSource</code>","text":"<p>This is enabled by default, however if it is not enabled the <code>.ref</code> attribute will be left as <code>null</code>, and byte to javascript string indices will not be calculated which can save time, especially if you don't care about where the error occurred, and instead just on the syntax tree result.</p>"},{"location":"artifact/shared/","title":"Using the Shared Artifact","text":"<p>This artifact is actually just a clone of the <code>Shared</code> namespace within <code>bnf-parser</code> with some functions embedded from <code>wasm.Runner</code>.</p> <p>Namespaces</p> <ul> <li><code>AssertUnreachable</code></li> <li><code>DecodeBase64</code></li> <li><code>ParserError</code></li> <li><code>Reference</code></li> <li><code>ReferenceRange</code></li> <li><code>SyntaxNode</code></li> </ul> <p>There are also some extra functions which are purely there for the bnf artifacts to import, and not intended for direct use</p> <ul> <li><code>Decode</code></li> <li><code>InitParse</code></li> <li><code>Parse</code></li> <li><code>MapBytes2String</code></li> <li><code>MapTreeRefs</code></li> <li><code>Offset</code></li> </ul>"},{"location":"legacy/","title":"Legacy","text":"<p>These documentation is for anyone attempting to use the older <code>v3.0</code> APIs, while they are still fully functional and unchanged, they are now deprecated and will be based out. However you can still read the documentation for them here.</p>"},{"location":"legacy/introduction/","title":"Introduction","text":"<p>Deprecated</p> <p>These features are all deprecated and will not be updated While they are still available within <code>v4.0</code> under the <code>legacy</code> namespace However they will be phased out by the next major release</p> <p>BNF-Parser is a simple library for generating syntax parsers based on deterministic BNF syntax descriptions. It includes a few changes from standard BNF forms to help produce cleaner syntax tree outputs.</p>"},{"location":"legacy/introduction/#example","title":"Example","text":"<p>First, provide the BNF representation of your language and parse it into a syntax tree. Then, compile the tree into a representation that is ready to parse syntax trees for the compiled language.</p> <pre><code>import { legacy } from \"bnf-parser\";\n\nlet result = legacy.BNF.parse(LANGUAGE_BNF);\nlet tree = legacy.Compile(result);\n\nlet syntax = tree.parse(FILE);\n</code></pre> <p>You can save a compiled BNF as a JSON file and reload it later: <pre><code>// Save the syntax tree\nfs.writeFileSync(path, JSON.stringify(tree.serialize()));\n\n// Load the compiled syntax tree\nlet tree = new legacy.Parser(\nJSON.parse( fs.readFileSync(path, 'utf8') )\n);\n</code></pre></p>"},{"location":"migrate/v4/","title":"Migrating to Version 4","text":"<p>With the introduction of 4.0 we had to change our package type to <code>module</code> due to some new dependencies. This will likely cause a lot of issues with any project not configured to act as a <code>module</code> and instead use <code>commonjs</code>.</p> <p>In these cases we recommend you move <code>bnf-parser</code> to a dev dependency before upgrading. Once you've installed the new version follow the CLI tutorial and onwards to use generated artifacts instead of directly interfacing with the library.</p> <p>The 4.0 release of the library is not intended to be used directly as a library, but instead as more of a <code>CLI</code> tool for compiling your bnfs down to an optimised parser with type definitions.</p>"},{"location":"syntax/","title":"Bnf Syntax","text":"<p>Here is the full syntax for how to write a <code>bnf</code> represented in our <code>bnf</code> format. If you're experienced you might notice there are some slight differences making our syntax slightly more modern. For those who aren't experienced with <code>bnf</code> syntax, don't worry we will go into it in detail. <pre><code>program ::= %w* ( def %w* )+ ;\n\n\n# Consumes a single wild character\nany ::= !\"\" ;\n\n# Whitespace\nw ::= comment | \" \" | \"\\t\" | \"\\n\" | \"\\r\" ;\n    comment ::= \"#\" !\"\\n\"* \"\\n\" ;\n\nname ::= ...( letter | digit | \"_\" )+ ;\n    letter ::= \"a\"-&gt;\"z\" | \"A\"-&gt;\"Z\" ;\n    digit ::= \"0\"-&gt;\"9\" ;\n\nconstant ::= single | double ;\n    double ::= %\"\\\"\" ( ( \"\\\\\" ...any ) | !\"\\\"\"+ )* %\"\\\"\" ;\n    single ::= %\"\\'\" ( ( \"\\\\\" ...any ) | !\"\\'\"+ )* %\"\\'\" ;\n\ndef ::= ...name %w+ %\"::=\" %w* expr %w* %\";\" ;\n\nexpr ::= expr_arg %w* ( ...expr_infix? %w* expr_arg %w* )* ;\n    expr_arg ::= expr_prefix ( constant | expr_brackets | ...name ) ...expr_suffix? ;\n    expr_prefix ::= \"%\"? \"...\"? \"!\"? ;\n    expr_infix  ::= \"-&gt;\" | \"|\" ;\n    expr_suffix ::= \"*\" | \"?\" | \"+\" ;\n    expr_brackets ::= %\"(\" %w* expr %w* %\")\" ;\n</code></pre></p> <p>All syntax trees follow the same general structure, where all branches can only have <code>SyntaxNode[]</code> as their value, and all leaves will have <code>string</code> values.</p> <p>All leaf notes will have the <code>.type</code> of <code>literal</code>, no matter what their naming originally was.</p>"},{"location":"syntax/#terms","title":"Terms","text":"<p>Every term must start with a name, which can be made out of letters, numbers, and <code>_</code>. After the name you put a <code>::=</code> to start the expression, and must end it with a <code>;</code>. This semicolon is to allow for multiline terms when things get complex.</p>"},{"location":"syntax/#sequence","title":"Sequence","text":"<p>All terms start with a sequence, meaning a series of things that must successfully parse for the term to be valid. <pre><code># will only accept \"ab\" as input\n# just \"b\" will fail the entire sequence\nprogram ::= \"a\" \"b\" ;\n</code></pre></p>"},{"location":"syntax/#select","title":"Select","text":"<p>A term may start with a select expression, however it will be parsed as if the term had a sequence, of which the first element was a select. This is to help reduce how much a syntax tree layout changes with small changes to the bnf sequence.</p> <p>You don't want minor tweaks to your BNF requiring major code changes due to your syntax tree now being represented majorly different.</p> <p>Selects can be chained which will form one large list of options, and a select will resolve as the first child is matches with.</p> <pre><code>program ::= \"a\" | \"b\" | \"c\" ;\n</code></pre> <p>This will match any single <code>a</code>, <code>b</code>, or <code>c</code> - and if it matches anyone of them the resulting syntax tree would be the same as if that option was just directly in the sequence. <pre><code># with input \"b\"\nsel ::= \"a\" | \"b\" | \"c\" ;\nseq ::= \"b\" ;\n</code></pre> Matching either of these two terms with the input <code>b</code> will create an identical syntax tree.</p> <p>About determinism</p> <p>A select will always take the first matching option, this means your option order will matter in some cases. <pre><code># input \"baa\"\nsuccess ::= \"baa\" | \"b\" ;\nfail    ::= \"b\" | \"baa\" ;\n</code></pre></p>"},{"location":"syntax/#interaction-with-sequence","title":"Interaction with Sequence","text":"<p>If you use sequences and selects in a single expression he behaviour will flip flop between the two modes accordingly. We strongly recommend using brackets if you indent to mix these to make behaviour more clear.</p> <pre><code>program ::= \"a\" \"b\" | \"c\" \"d\" | \"e\" | \"f\";\nresolve ::= \"a\" ( \"b\" | \"c\" ) ( \"d\" | \"e\" | \"f\" ) ;\n</code></pre>"},{"location":"syntax/#literals","title":"Literals","text":"<p>All literals as just strings of characters, these must start and end with a <code>\"</code>, (i.e. <code>\"Hello There\"</code>). For a literal to match successfully the entire literal must exactly match.</p> <p>Literals also allow certain escape characters to help with encoding certain characters within a string.</p> Code Result <code>\\b</code> Backspace <code>\\f</code> Form Feed <code>\\n</code> New Line <code>\\r</code> Carriage Return <code>\\t</code> Horizontal Tab <code>\\v</code> Vertical Tab <code>\\x??</code> The two characters following the <code>\\x</code> must be hexadecimal digits, these digits represent the character code of the character you want to match at this point (<code>\\x6b</code> = <code>k</code>) - Unrecognised escapes will result in just the character after the slash"},{"location":"syntax/#range","title":"Range","text":"<p>A range will match any character between the first and last literal. These two literals must both be a single character. This works based on checking if the byte is in range of the byte value of the two characters. Be mindful of this, because this will not match anything <code>\"z\"-&gt;\"a\"</code>, and this <code>\"A\"-&gt;\"z\"</code> will also match some control characters between the upper case and lowercase alphabets. <pre><code>letter ::= \"a\"-&gt;\"z\" | \"A\"-&gt;\"Z\" ;\n</code></pre></p>"},{"location":"syntax/#brackets","title":"Brackets","text":"<p>This allows you to represent a sequence with a sequence, or even a sequence with a select. The insides of the bracket will resolve to either a <code>sequence</code> or a <code>select</code> depending on what's inside of them <pre><code>a ::= ( \"a\"   \"b\" ) ; # bracket resolved to a child sequence\na ::= ( \"a\" | \"b\" ) ; # bracket resolved to a child select\n</code></pre></p>"},{"location":"syntax/#not","title":"Not","text":"<p>When this <code>!</code> is placed before any operand will consume the inverse of it. For instance if you want any character that isn't a vowel. <pre><code>program ::= !( \"a\" | \"e\" | \"i\" | \"u\" | \"o\" ) ;\n</code></pre></p>"},{"location":"syntax/#omit","title":"Omit","text":"<p>This will omit <code>%</code> the resulting SyntaxNode of what ever you're applying it to from the resulting syntax tree. This can be helpful for discarding unuseful data such as whitespace. <pre><code>program ::= name %\" \" name %comment ;\n</code></pre></p>"},{"location":"syntax/#gather","title":"Gather","text":"<p>This operator will apply on any operand, and flatten the resulting tree structure into a single string. This can be helpful for further sanitising of the syntax tree for features you don't care about, such as the specific structure of how a name is parsed.</p> <pre><code>program ::= ...name ; # name will resolve name to a literal\nname ::= letter letter letter ;\n</code></pre>"},{"location":"syntax/#repetition","title":"Repetition","text":"<p>Repetitions can be applied at the end of any operand, and tells the parser how many times it should consume the pattern until it stops, and also it fail if it doesn't consume if enough times. <pre><code>term  # once\nterm? # one or zero\nterm+ # at least once\nterm* # zero or more\n</code></pre></p> <p>This will actually apply to certain other operations directly modifying their behaviour. A not will tell it how many characters to consume which will resolve as a single node with a multi-character string. A range will also behave similarly as not when modified.</p>"}]}