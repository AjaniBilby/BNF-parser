{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-400","title":"Version 4.0.0","text":""},{"location":"changelog/#additions","title":"Additions","text":"<ul> <li> Ability to compile BNFs down to WebAssembly</li> <li> Ability to generate type definitions for the syntax tree of a given BNF</li> <li> Now able to represent characters by char code using hexadecimal in literals (wasm only) <code>\\x41</code></li> </ul>"},{"location":"changelog/#changes","title":"Changes:","text":"<ul> <li> All previous APIs moved under the <code>legacy</code> namespace</li> </ul>"},{"location":"changelog/#fixes","title":"Fixes:","text":"<ul> <li> Count not working when applied directly to a range (i.e. <code>\"a\"-&gt;\"z\"+</code>)</li> </ul>"},{"location":"changelog/#version-316","title":"Version 3.1.6","text":""},{"location":"changelog/#patch","title":"Patch:","text":"<ul> <li> NPM ignore some how removed <code>/bin/lib</code></li> </ul>"},{"location":"changelog/#version-315","title":"Version 3.1.5","text":""},{"location":"changelog/#tweaks","title":"Tweaks:","text":"<ul> <li> Better webpack support     No reliance on <code>fs</code> for deployment.     Now generates a javascript file containing all start up requirements.</li> </ul>"},{"location":"changelog/#version-314","title":"Version 3.1.4","text":""},{"location":"changelog/#tweaks_1","title":"Tweaks:","text":"<ul> <li> Added extra test case <code>Sequalize</code></li> <li> Clarified readme documentation further</li> <li> Synced up some documentation inconsistencies between NPM and Github</li> <li> Fixed typo in previous version number's changelog</li> <li> Got ChatGPT-4 to read my homework (read over the readme and helped clarify a few things)</li> </ul>"},{"location":"changelog/#version-313","title":"Version 3.1.3","text":""},{"location":"changelog/#fixes_1","title":"Fixes:","text":"<ul> <li> Fixed missing bound check on getting reach of a SyntaxNode</li> </ul>"},{"location":"changelog/#tweaks_2","title":"Tweaks:","text":"<ul> <li> Clarified readme documentation</li> </ul>"},{"location":"changelog/#version-312","title":"Version 3.1.2","text":""},{"location":"changelog/#fixes_2","title":"Fixes:","text":"<ul> <li> Updated readme to clarify behaviour of select statements</li> </ul>"},{"location":"changelog/#version-311","title":"Version 3.1.1","text":""},{"location":"changelog/#fixes_3","title":"Fixes:","text":"<ul> <li> Incorrect referencing for syntax errors.</li> </ul>"},{"location":"changelog/#version-310","title":"Version 3.1.0","text":""},{"location":"changelog/#added","title":"Added:","text":"<ul> <li> Documentation dictating the syntax tree structure generated</li> </ul>"},{"location":"changelog/#changes_1","title":"Changes:","text":"<ul> <li> Updates to test case logging</li> <li> New internal string parsing method</li> <li> Rearranged documentation</li> <li> Runtime type check on <code>Compile</code> for non TS users</li> <li> Restructured output Syntax tree to make the layout more stable over BNF changes.</li> </ul>"},{"location":"cli/","title":"CLI Usage","text":"<pre><code>npx bnf-compile ./bnf/\n</code></pre> <p>Once you have <code>bnf-parser</code> installed simply run <code>npx bnf-compile ./bnf/</code> where <code>./bnf/</code> is actually the folder where your bnfs are stored. After running this you will notice multiple artifacts will be generated which is what you will then <code>import</code>/<code>require</code> into your project.</p> <p>Please note that by default this command will generate javascript modules using the <code>import</code>/<code>export</code> syntax, if you are running an environment which does not support <code>import</code>/<code>export</code>, the CLI will not currently be able export artifacts useable in your project.</p>"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#installation","title":"Installation","text":"<p>We recommend for most people installing <code>bnf-parser</code> as purely a dev dependency, and then you never <code>import</code>/<code>require</code> it into your project. However if for some reason you want to generate syntax parsers for a bnf which is unknown at compile time, then you will need to install <code>bnf-parser</code> as a regular dependency.</p> <pre><code>npm install bnf-parser --save-dev\n</code></pre> <p>Optionally if you want to be able to use the cli commands anywhere without setting up a whole npm dependecy environment you can install globally using: <pre><code>npm install bnf-parser -g\n</code></pre></p>"},{"location":"test/","title":"Experiment Online","text":"Browser Performance Warning <p>When you hit <code>run</code> in this playground it compiles the BNF down to WASM, then it uses that wasm to parse the input string, then finally the result is shown</p> <p>This is not indicative of the performance you can expect by actually using this library properly, and the entire compilation step is skipped at runtime as it's already been completed during pre-compilation.</p> <p>If you want to try with code in your browser use RunKit+</p>"},{"location":"api/","title":"API","text":"<p>Warning</p> <p>It is highly recommended to not directly use the APIs unless necessary, and instead rely on artifacts generated by the CLI</p> <p>Using the API can cause a lot of confusion for non-maintainers such as some functions throwing <code>ParseError</code> which is a shared class between <code>legacy</code> and new code, but some other's actually using <code>_shared.ParseError</code> however it will appear under the same name.</p> <p>This is due to some components of this library being fundamental core components, and others are actually compiled by the library itself and using these artifacts as part of itself in a bootstrapping process.</p> <p>Hence there are multiple versions of some types</p> <ul> <li><code>_shared</code></li> <li><code>bnf</code></li> <li><code>legacy</code></li> <li><code>types</code></li> <li><code>wasm</code></li> </ul>"},{"location":"api/bnf/","title":"<code>bnf</code> Namespace","text":"<p>TODO</p>"},{"location":"api/shared/","title":"<code>_shared</code> Namespace","text":""},{"location":"api/shared/#parseerror","title":"ParseError","text":"<p>This class is simply used to bundle a message with a ReferenceRange, while it is primarily used to represent an error while parsing, it is also used for errors in compilation and other events where a message and a ReferenceRange are necessary.</p> <pre><code>export class ParseError {\nmsg: string\nref: ReferenceRange\n\nconstructor(msg: string, ref: ReferenceRange);\ntoString(): string;\n}\n</code></pre>"},{"location":"api/shared/#syntaxnode","title":"SyntaxNode","text":"<p>This class can represent both a branch and a leaf node of a syntax tree. If these are generated by a parse call with source mapping turned off, it and all it's children will share a single instance of ReferenceRange with an invalid column and line number.</p> <p>Please be mindful of this if you attempt to mutate the references on a non-source mapped SyntaxNode.</p> <pre><code>export class SyntaxNode {\ntype : string; // the name of this branch/leaf\nstart: number; // the byte index this node starts at\nend  : number; // the byte index this node ends at\ncount: number; // the number of children, or number of bytes this holds (branch/leaf)\nvalue: SyntaxNode[] | string;\nref: ReferenceRange;\n\nconstructor (type: string, start: number, end: number, count: number, ref: ReferenceRange);\n}\n</code></pre>"},{"location":"api/shared/#reference","title":"Reference","text":"<pre><code>export class Reference {\nline : number; // numbering starts at 1\ncol  : number; // numbering starts at 1\nindex: number; // numbering starts at 0 (JS string index)\n\nconstructor(line: number, col: number, index: number)\nclone(): Reference;\ntoString(): string;\n\nstatic blank() {\nreturn new Reference(1,1,0);\n}\n}\n</code></pre>"},{"location":"api/shared/#referencerange","title":"ReferenceRange","text":"<pre><code>export class ReferenceRange {\nstart: Reference;\nend:   Reference;\n\nconstructor(from: Reference, to: Reference)\nspan(other: ReferenceRange) // Merges itself with another range\nclone(): ReferenceRange\ntoString(): string\n\n// Non-destructively takes two ranges, and returns a new range spanning both\nstatic union(a: ReferenceRange, b: ReferenceRange){\nreturn new ReferenceRange(\na.start.index &lt; b.start.index ? a.start.clone() : b.start.clone(), // Smallest\na.end.index   &gt; b.end.index   ? a.end.clone()   : b.end.clone(),   // Largest\n);\n}\n\n// Non-destructively takes two ranges, and returns a new range of the intersection of both\n// If the two ranges do not intersect you will end up with the range between them\nstatic intersection(a: ReferenceRange, b: ReferenceRange)\n\nstatic blank() {\nreturn new ReferenceRange(Reference.blank(), Reference.blank());\n}\n}\n</code></pre>"},{"location":"api/shared/#assertunreachable","title":"AssertUnreachable","text":"<p>This function is simply a helper function for ensuring you have checked all possible states for a given node.</p> <pre><code>export function AssertUnreachable(x: never): never\n</code></pre> <p>Example bnf<pre><code>component ::= literal | constant | expr ;\n</code></pre> typescript<pre><code>switch (component.type) {\ncase \"literal\": break;\ncase \"constant\": break;\ndefault: AssertUnreachable(component); // will cause compile time error\n// as expr is missing\n}\n</code></pre></p>"},{"location":"api/shared/#decodebase64","title":"DecodeBase64","text":"<p>This function is simply used by artifacts, and not intended for end-user use, but could still be helpful.</p> <pre><code>export function DecodeBase64(base64: string): Uint8Array;\n</code></pre>"},{"location":"api/types/","title":"<code>types</code> Namespace","text":"<p>TODO</p>"},{"location":"api/wasm/","title":"<code>wasm</code> Namespace","text":"<p>TODO</p>"},{"location":"artifact/","title":"Artifacts","text":"<p>After using the CLI to build your artifacts you will see for every bnf file in that folder two files will be generated. <code>{name}.js</code> which includes all of the runtime required code specific to this parser, and a <code>{name}.d.ts</code>. If you include the <code>.js</code> file, typescript will automatically read from the <code>d.ts</code> for you to find out the type structure of your syntax tree.</p> <p>You will also notice a <code>shared.d.ts</code> and a <code>shared.js</code>, this is a small artifact which is shared between all bnf parsers generated to help unify certain types such as <code>ParseError</code>. All of the generated <code>.d.ts</code> and <code>.js</code> must remain in the same folder as each-other, however you can now move them as a group anywhere.</p> <p>Anything generated by the cli will be referred to as an <code>artifact</code> to differentiate them from any component of the <code>bnf-parser</code> library itself.</p>"},{"location":"artifact/individual/","title":"Using the BNF generated Artifact","text":""},{"location":"artifact/individual/#types","title":"Types","text":"<p>For every term in the BNF node there will also be a type, that type name will start with <code>Term_</code>; with the first letter of the term name capitalized. This will be a type representing the syntax structure at that node.</p> <p>Examples <pre><code>program  -&gt; Term_Program\nname     -&gt; Term_Name\nexpr_arg -&gt; Term_Expr_arg\n</code></pre></p>"},{"location":"artifact/individual/#nodes","title":"Nodes","text":"<p>Every node (including terms, and literals) have the following general type, which is then refined by the compiled <code>d.ts</code> <pre><code>type SyntaxNode = {\ntype  : string;\nroot  : string | SyntaxNode[];\nstart : number;                // the BYTE index this node starts at (not string index)\nend   : number;                // the BYTE index the node ends at    (not string index)\nref   : null | ReferenceRange  // see shared artifact\n}\n</code></pre></p>"},{"location":"artifact/individual/#functions","title":"Functions","text":"<p>For every term in your BNF there will be a function with the following syntax. When you supply this function with a string it will attempt to parse the string starting from the specific term in the BNF.</p> <p>This means that you could actually group multiple different parsers into one artifact by including them all in the same BNF, then you just call the specific entry points for each one.</p> <pre><code>function Parse_Program(input: string, mapSource = true): {\nroot       : Term_Program; // the root node of the syntax tree\nreachBytes : number;       // how many bytes where consumed\nisPartial  : boolean;      // did only part of the input parse?\n}\n</code></pre>"},{"location":"artifact/individual/#argument-mapsource","title":"Argument <code>mapSource</code>","text":"<p>This is enabled by default, however if it is not enabled the <code>.ref</code> attribute will be left as <code>null</code>, and byte to javascript string indices will not be calculated which can save time, especially if you don't care about where the error occurred, and instead just on the syntax tree result.</p>"},{"location":"artifact/shared/","title":"Using the Shared Artifact","text":"<p>This artifact is actually just a clone of the <code>Shared</code> namespace within <code>bnf-parser</code> with some functions embedded from <code>wasm.Runner</code>.</p> <p>Namespaces</p> <ul> <li><code>ParserError</code></li> <li><code>SyntaxNode</code></li> <li><code>ReferenceRange</code></li> <li><code>Reference</code></li> <li><code>DecodeBase64</code></li> </ul> <p>There are also some extra functions which are purely there for the bnf artifacts to import, and not intended for direct use</p> <ul> <li><code>InitParse</code></li> <li><code>MapBytes2String</code></li> <li><code>MapTreeRefs</code></li> <li><code>Parse</code></li> <li><code>Decode</code></li> </ul>"},{"location":"legacy/","title":"Legacy","text":"<p>These documentation is for anyone attempting to use the older <code>v3.0</code> APIs, while they are still fully functional and unchanged, they are now deprecated and will be based out. However you can still read the documentation for them here.</p>"},{"location":"legacy/introduction/","title":"Introduction","text":"<p>Deprecated</p> <p>These features are all deprecated and will not be updated While they are still available within <code>v4.0</code> under the <code>legacy</code> namespace However they will be phased out by the next major release</p> <p>BNF-Parser is a simple library for generating syntax parsers based on deterministic BNF syntax descriptions. It includes a few changes from standard BNF forms to help produce cleaner syntax tree outputs.</p>"},{"location":"legacy/introduction/#example","title":"Example","text":"<p>First, provide the BNF representation of your language and parse it into a syntax tree. Then, compile the tree into a representation that is ready to parse syntax trees for the compiled language.</p> <pre><code>import { legacy } from \"bnf-parser\";\n\nlet result = legacy.BNF.parse(LANGUAGE_BNF);\nlet tree = legacy.Compile(result);\n\nlet syntax = tree.parse(FILE);\n</code></pre> <p>You can save a compiled BNF as a JSON file and reload it later: <pre><code>// Save the syntax tree\nfs.writeFileSync(path, JSON.stringify(tree.serialize()));\n\n// Load the compiled syntax tree\nlet tree = new legacy.Parser(\nJSON.parse( fs.readFileSync(path, 'utf8') )\n);\n</code></pre></p>"}]}