{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BNF-Parser","text":"<p>New docs coming soon</p>"},{"location":"legacy/","title":"Legacy","text":"<p>BNF-Parser is a simple library for generating syntax parsers based on deterministic BNF syntax descriptions. It includes a few changes from standard BNF forms to help produce cleaner syntax tree outputs.</p> <ul> <li>Legacy</li> <li>Example</li> <li>API</li> <li>BNF Syntax<ul> <li>Escape Codes</li> <li>Repetition Operator <code>?</code>, <code>+</code>, <code>*</code></li> <li>Omit Operator <code>%</code></li> <li>Not Operator <code>!</code></li> <li>Range Operator <code>-&gt;</code></li> </ul> </li> <li>Imports<ul> <li>BNF</li> <li>Parser</li> <li>Compile</li> <li>SyntaxNode</li> <li>ParseError</li> <li>Reference</li> <li>Reference Range</li> </ul> </li> <li>Syntax Tree</li> <li>Sequences</li> <li>Select</li> <li>Omit</li> <li>Gather</li> <li>Not</li> <li>Range</li> <li>Repetition</li> <li>Literal</li> </ul>"},{"location":"legacy/#example","title":"Example","text":"<p>First, provide the BNF representation of your language and parse it into a syntax tree. Then, compile the tree into a representation that is ready to parse syntax trees for the compiled language.</p> <pre><code>import { BNF, Compile } from \"bnf-parser\";\n\nlet result = BNF.parse(LANGUAGE_BNF);\nlet tree = Compile(result);\n\nlet syntax = tree.parse(FILE);\n</code></pre> <p>You can save a compiled BNF as a JSON file and reload it later: <pre><code>// Save the syntax tree\nfs.writeFileSync(path, JSON.stringify(tree.serialize()));\n\n// Load the compiled syntax tree\nlet tree = new Parser(\nJSON.parse( fs.readFileSync(path, 'utf8') )\n);\n</code></pre></p>"},{"location":"legacy/#api","title":"API","text":""},{"location":"legacy/#bnf-syntax","title":"BNF Syntax","text":"<pre><code>program ::= %w* ( def %w* )+ ;\n\n# Consumes a single wild character\nany ::= !\"\" ;\n\n# Whitespace\nw ::= comment | \" \" | \"\\t\" | \"\\n\" | \"\\r\" ;\n    comment ::= \"#\" !\"\\n\"* \"\\n\" ;\n\nname ::= ...( letter | digit | \"_\" )+ ;\n    letter ::= \"a\"-&gt;\"z\" | \"A\"-&gt;\"Z\" ;\n    digit ::= \"0\"-&gt;\"9\" ;\n\nconstant ::= single | double ;\n    double ::= %\"\\\"\" ( ( \"\\\\\" ...any ) | !\"\\\"\"+ )* %\"\\\"\" ;\n    single ::= %\"\\'\" ( ( \"\\\\\" ...any ) | !\"\\'\"+ )* %\"\\'\" ;\n\ndef ::= ...name %w+ %\"::=\" %w* expr %w* %\";\" ;\n\nexpr ::= expr_arg %w* ( ...expr_infix? %w* expr_arg %w* )* ;\n    expr_arg ::= expr_prefix ( constant | expr_brackets | ...name ) ...expr_suffix? ;\n    expr_prefix ::= \"%\"? \"...\"? \"!\"? ;\n    expr_infix  ::= \"-&gt;\" | \"|\" ;\n    expr_suffix ::= \"*\" | \"?\" | \"+\" ;\n    expr_brackets ::= %\"(\" %w* expr %w* %\")\" ;\n</code></pre>"},{"location":"legacy/#escape-codes","title":"Escape Codes","text":"Code Result <code>\\b</code> Backspace <code>\\f</code> Form Feed <code>\\n</code> New Line <code>\\r</code> Carriage Return <code>\\t</code> Horizontal Tab <code>\\v</code> Vertical Tab - Unrecognised escapes will result in just the character after the slash"},{"location":"legacy/#repetition-operator","title":"Repetition Operator <code>?</code>, <code>+</code>, <code>*</code>","text":"<p>Only one repetition mark should exist per argument. <pre><code>term # once\nterm? # one or zero\nterm+ # at least once\nterm* # zero or more\n</code></pre></p> <p>Resulting syntax layout</p>"},{"location":"legacy/#omit-operator","title":"Omit Operator <code>%</code>","text":"<pre><code>%term\n</code></pre> <p>The omit operator is placed in front of a single term and must be the front-most operator, preceding any <code>not</code> or <code>gather</code> operators. It causes the syntax under this operator to be removed from the final syntax tree but still remain part of syntax validation.</p> <p>Resulting syntax layout</p>"},{"location":"legacy/#not-operator","title":"Not Operator <code>!</code>","text":"<pre><code>!term\n</code></pre> <p>The not operator is used to consume a single token as long as the term it precedes does not match. It can also be used with repetition markers to consume multiple tokens that do not match the specified term.</p> <pre><code>!\"a\"   # Matches any single character except \"a\"\n!\"a\"*  # Matches any sequence of characters excluding \"a\"\n!\"a\"+  # Matches any sequence of characters with at least one character, excluding \"a\"\n</code></pre> <p>This can be very powerful when used in conjunction with other operations such as select <pre><code>non_vowel ::= !(\n  \"a\" | \"e\" | \"i\" | \"o\" | \"u\" |\n  \"A\" | \"E\" | \"I\" | \"O\" | \"U\"\n) ; # this will match any non-vowel, which includes non-letter characters\n</code></pre></p> <p>Resulting syntax layout</p>"},{"location":"legacy/#range-operator-","title":"Range Operator <code>-&gt;</code>","text":"<pre><code>term -&gt; term\n</code></pre> <p>The range operator is used to define a range between two single-length constants, allowing the parser to match any character within the specified range. This is useful for simplifying character ranges in BNF descriptions.</p> <pre><code>\"a\"-&gt;\"z\"  # Matches a single character within the range \"a\" to \"z\"\n\"a\"-&gt;\"z\"* # Matches a sequence of characters within the range \"a\" to \"z\"\n</code></pre> <p>The range operator can be combined with repetition markers to control the number of characters consumed within the specified range.</p> <p>Resulting syntax layout</p>"},{"location":"legacy/#imports","title":"Imports","text":""},{"location":"legacy/#bnf","title":"BNF","text":"<p>This is a pre-initialised BNF parser, which can be given a BNF string input.</p> <pre><code>const BNF: Parser;\n</code></pre>"},{"location":"legacy/#parser","title":"Parser","text":"<p>The <code>Parser</code> class is used to parse input based on the syntax tree generated by the <code>BNF</code> class.</p> <pre><code>class Parser {\nconstructor(blob: any)\n\n// Attempts to parse a language into a syntax tree\nparse(\ninput   : string,             // The text to be parsed\npartial : boolean = false,    // Whether the entire string needs to be consucanmed\nentry   : string  = \"program\" // Where parsing should start from in the BNF definition\n): SyntaxNode | ParseError\nsetVerbose(mode: boolean) { }\n}\n</code></pre>"},{"location":"legacy/#compile","title":"Compile","text":"<p>The <code>Compile</code> function is given a <code>SyntaxNode</code> tree generated from the pre-initialized <code>BNF</code> parser - from which it can generate a new parser.</p> <pre><code>function Compile(tree: SyntaxNode): Parser\n</code></pre>"},{"location":"legacy/#syntaxnode","title":"SyntaxNode","text":"<p>The <code>SyntaxNode</code> class represents a node in the generated syntax tree.</p> <p>The type value of a <code>SyntaxNode</code> is typically the name of the term being matched - i.e. the root node will be <code>program</code> by default. However it can be a generated name in the case of brackets <code>(...)</code> and repetition markers such as <code>+</code> <code>(...)+</code>.</p> <pre><code>class SyntaxNode {\ntype  : string;\nvalue : SyntaxValue;\nref   : ReferenceRange;\n\nconstructor(type: string, value: SyntaxValue, ref: ReferenceRange) {};\n\n// Merges all of it's child syntax node values into a single string\nflat(): string {};\n}\n\ntype SyntaxValue = SyntaxNode[] | string;\n</code></pre>"},{"location":"legacy/#parseerror","title":"ParseError","text":"<p>The <code>ParseError</code> class represents an error that occurred during parsing of the input.</p> <pre><code>class ParseError {\nstack : string[]\nmsg   : string\nref   : ReferenceRange\n\nconstructor(msg: string, ref: ReferenceRange) { }\n\n// Adds a string to the top of the call stack\n//   (for internal use)\nadd_stack(elm: string) { }\n\n// If this error contains a pass stack\n//   (for internal use)\nhasStack(): boolean { }\n\n// Stringifies itself for printing/debug\ntoString() { }\n}\n</code></pre>"},{"location":"legacy/#reference","title":"Reference","text":"<p>The <code>Reference</code> class is a cursor to describe a certain point in a string input.</p> <pre><code>class Reference {\nindex : number;\nline  : number;\ncol   : number;\n\nconstructor(line: number, col: number, index: number) { }\n\n// Will shift the reference one position forwards\nadvance(newline: boolean = false) { }\n\n// Returns a deep copy of itself\nclone(): Reference { }\n\n// Stringifies itself for printing/debug\ntoString(): string { }\n}\n</code></pre>"},{"location":"legacy/#reference-range","title":"Reference Range","text":"<p>The <code>ReferenceRange</code> class uses two <code>Reference</code>s to describe a range within the text input.</p> <pre><code>class ReferenceRange {\nstart : Reference;\nend   : Reference;\n\nconstructor(from: Reference, to: Reference) { }\n\n// Alters itself so the rang supplied now fits within the range of itself\n//  Basically takes the min from, and the max to references and applies them to itself\nspan(other: ReferenceRange) { }\n\n// Returns a deep copy of itself\nclone(): ReferenceRange { }\n\n// Stringifies itself for printing/debug\ntoString(): string { }\n}\n</code></pre>"},{"location":"legacy/#syntax-tree","title":"Syntax Tree","text":"<p>There are two primary abstractions in generating syntax trees from BNF: sequences and selections.</p>"},{"location":"legacy/#sequences","title":"Sequences","text":"<p>A sequence is an ordered list of elements that form a match. A top-level sequence (right side of the <code>::=</code>) will resolve with the <code>SyntaxNode.type</code> of the matching name (the name on the left of the <code>::=</code>). Sub-sequences within parentheses <code>()</code> will appear as a syntax node with the name <code>(...)</code> and will be evaluated similarly to the top level.</p> <p>If a repetition marker like name+ is used, additional nodes with the type <code>(...)+</code> will be added, and their children will represent the number of times the pattern matched.</p>"},{"location":"legacy/#select","title":"Select","text":"<p>A selection will resolve as the syntax tree of the first matching option. For example, if you have the selection statement <code>variable | number</code>, and the parser matches a <code>variable</code>, it would be the same as having a <code>variable</code> in that position in the sequence.</p> <p>The selection statement will always consume the first valid option, so you should order your selection statements accordingly. For example: i.e. <pre><code>program ::= \"a\" | \"aa\" ;\n</code></pre> In this case, providing the input \"aa\" will fail, as it will consume the single \"a\", and since there is no repetition, the program will end, leaving the second \"a\" unconsumed. As the syntax did not parse the whole string, this is considered an error.  See Parser for information on allowing partial matches.</p>"},{"location":"legacy/#omit","title":"Omit","text":"<p>Omit statements within a sequence will be removed, and they will not be present in the output syntax tree. However, they are still crucial for a successful match. If they are within a selection, they will be visible with <code>SyntaxNode.type</code> of <code>omit</code> and no child nodes.</p>"},{"location":"legacy/#gather","title":"Gather","text":"<p>Gather does not change the output syntax tree structure relative to the sequence or selection it is within. However, it combines all of its child nodes into a single string. Note that this reflects the effects of any omit operations within the child nodes.</p>"},{"location":"legacy/#not","title":"Not","text":"<p>The <code>SyntaxNode.values</code> will be a single string containing all characters consumed until it matched the target expression of the repetition limit is reached.</p>"},{"location":"legacy/#range","title":"Range","text":"<p>Ranges will appear with the <code>SyntaxNode.type</code> of <code>range</code> with <code>SyntaxNode.value</code> being a single string with the characters consumed by this expression, accounting for any repetition markers (so a range with <code>+</code> will be a string of length at least one).</p>"},{"location":"legacy/#repetition","title":"Repetition","text":"<p>A repetition marker creates its own node in the syntax tree, with its children representing the value of each repetition. The <code>SyntaxNode.type</code> value of this node will be the <code>(...)</code> followed by the repetition marker used, such as: <code>(...)+</code>, <code>(...)*</code>, or <code>(...)?</code>.</p>"},{"location":"legacy/#literal","title":"Literal","text":"<p>Literals will appear with the <code>SyntaxNode.type</code> of <code>literal</code> and <code>SyntaxNode.value</code> as an exact copy of the literal as a string.</p>"}]}